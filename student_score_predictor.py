# -*- coding: utf-8 -*-
"""Student_Score_Predictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zkFQn_dlrZWmQIXWIbNiSfofs-DJPD6D
"""

import pandas as pd
from google.colab import files
from IPython import get_ipython
from IPython.display import display

"""This code snippet is designed for use in Google Colab to allow a user to upload a file from their local machine into the Colab environment. Here's a breakdown:

Import Libraries:

import pandas as pd: Imports the pandas library, commonly used for data manipulation and analysis. While imported here, it's not directly used in the file upload process itself, but likely intended for subsequent data loading from the uploaded file.
from google.colab import files: Imports the files module from Google Colab, which provides functions for interacting with the user's local filesystem.
from IPython import get_ipython: Imports a function to get the current IPython kernel instance. This is often used in notebooks but isn't directly involved in the file upload.
from IPython.display import display: Imports a function to display objects in a rich format in the notebook. This is not directly used in the file upload code provided.
Initiate File Upload:

uploaded = files.upload(): This is the core command that triggers the file upload dialog in Google Colab. When this line is executed, a file browser will appear, allowing the user to select one or more files from their computer. The selected files are uploaded to the Colab session's temporary storage, and a dictionary containing the uploaded file names and their content as bytes is returned and assigned to the uploaded variable.
Iterate and Print Uploaded File Information:

for fn in uploaded.keys():: This loop iterates through the keys of the uploaded dictionary. The keys are the names of the files that were uploaded by the user.
print('User uploaded file "{name}" with length {length} bytes'.format(name=fn, length=len(uploaded[fn]))): Inside the loop, for each uploaded file, this line prints a message indicating the name of the file (fn) and the size of the file in bytes (len(uploaded[fn])).
In summary, this code uses the google.colab.files module to provide an interactive way for users to upload files to their Colab session and then confirms the upload by printing the names and sizes of the uploaded files.
"""

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

df=pd.read_csv('student_habits_performance.csv')

df.info()

df.head()

# @title age vs study_hours_per_day

from matplotlib import pyplot as plt
df.plot(kind='scatter', x='age', y='study_hours_per_day', s=32, alpha=.8)
plt.gca().spines[['top', 'right',]].set_visible(False)

# @title gender

from matplotlib import pyplot as plt
import seaborn as sns
df.groupby('gender').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

df.dtypes

df.isnull().sum()

df.select_dtypes(include='object').columns

df.select_dtypes(include='object')

df.duplicated().sum()

df=df.drop(columns=['student_id','internet_quality'])

df.select_dtypes(include='object')

df.info()

df=df.drop(columns=['netflix_hours'])

df.head()

# @title gender vs age

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(df['gender'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(df, x='age', y='gender', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

df['gender'].unique()

df.head()

df_original = df.copy()
df = pd.get_dummies(df, columns=['gender'], drop_first=False)

df.head()

df['part_time_job'].unique()

df = pd.get_dummies(df, columns=['part_time_job'], drop_first=False)

df.head()

df['diet_quality'].unique()

df = pd.get_dummies(df, columns=['diet_quality'], drop_first=False)

df['parental_education_level'].isnull().sum()

df['parental_education_level'] = df['parental_education_level'].fillna('Unknown')

df['parental_education_level'].isnull().sum()

df['parental_education_level'].unique()

df = pd.get_dummies(df, columns=['parental_education_level'], drop_first=False)

df.head()

df['extracurricular_participation'].unique()

df = pd.get_dummies(df, columns=['extracurricular_participation'], drop_first=False)

df.head()

df = df.astype(int)

df.head()

df.info()

X = df.drop('exam_score', axis=1)  # Inputs
y = df['exam_score']               # Target

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

from sklearn.ensemble import RandomForestRegressor

model = RandomForestRegressor(random_state=42)
model.fit(X_train, y_train)

from sklearn.metrics import mean_squared_error, r2_score

y_pred = model.predict(X_test)

print("MSE:", mean_squared_error(y_test, y_pred))
print("RÂ² Score:", r2_score(y_test, y_pred))

from sklearn.linear_model import LinearRegression

model = LinearRegression()
model.fit(X_train, y_train)

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

def evaluate_regression_model(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_true, y_pred)

    print(f"Mean Absolute Error (MAE): {mae:.4f}")
    print(f"Mean Squared Error (MSE): {mse:.4f}")
    print(f"Root Mean Squared Error (RMSE): {rmse:.4f}")
    print(f"R-squared (R2 ): {r2:.4f}")

y_pred = model.predict(X_test)
evaluate_regression_model(y_test, y_pred)

print(X.columns.tolist())

import pandas as pd

input_data = pd.DataFrame([{
    'age': 20,
    'study_hours_per_day': 4.5,
    'social_media_hours': 2,
    'attendance_percentage': 90,
    'sleep_hours': 7,
    'exercise_frequency': 3,
    'mental_health_rating': 8,
    'gender_Female': 0,
    'gender_Male': 1,
    'gender_Other': 0,
    'part_time_job_No': 1,
    'part_time_job_Yes': 0,
    'diet_quality_Fair': 0,
    'diet_quality_Good': 1,
    'diet_quality_Poor': 0,
    'parental_education_level_Bachelor': 0,
    'parental_education_level_High School': 1,
    'parental_education_level_Master': 0,
    'parental_education_level_Unknown': 0,
    'extracurricular_participation_No': 0,
    'extracurricular_participation_Yes': 1
}])

predicted_score = model.predict(input_data)
print(f"Predicted Exam Score: {predicted_score[0]:.2f}")

def predict_exam_score(model, input_dict):
    input_df = pd.DataFrame([input_dict])
    score = model.predict(input_df)[0]
    return round(score, 2)

# Example usage:
exam_score = predict_exam_score(model, input_data.iloc[0].to_dict())
print("Predicted Exam Score:", exam_score)

import pandas as pd

def encode_gender(gender):
    gender_Female = 0
    gender_Male = 0
    gender_Other = 0
    if gender == "Female":
        gender_Female = 1
    elif gender == "Male":
        gender_Male = 1
    elif gender == "Other":
        gender_Other = 1
    return gender_Female, gender_Male, gender_Other

def encode_extracurricular(value):
    yes = 0
    no = 0
    if value == "Yes":
        yes = 1
    elif value == "No":
        no = 1
    return no, yes

def encode_part_time_job(value):
    yes = 0
    no = 0
    if value == "Yes":
        yes = 1
    elif value == "No":
        no = 1
    return no, yes

def encode_parental_education(value):
    bachelor = 0
    high_school = 0
    master = 0
    unknown = 0
    if value == "Bachelor":
        bachelor = 1
    elif value == "High School":
        high_school = 1
    elif value == "Master":
        master = 1
    elif value == "Unknown":
        unknown = 1
    return bachelor, high_school, master, unknown

def encode_diet_quality(value):
    good = 0
    fair = 0
    poor = 0
    if value == "Good":
        good = 1
    elif value == "Fair":
        fair = 1
    elif value == "Poor":
        poor = 1
    return fair, good, poor

def predict_exam_score_flexible(model, input_data):
    # Handle gender encoding
    if 'gender' in input_data:
        gender_F, gender_M, gender_O = encode_gender(input_data['gender'])
        input_data.pop('gender')
        input_data['gender_Female'] = gender_F
        input_data['gender_Male'] = gender_M
        input_data['gender_Other'] = gender_O

    # Handle extracurricular_participation
    if 'extracurricular_participation' in input_data:
        no, yes = encode_extracurricular(input_data['extracurricular_participation'])
        input_data.pop('extracurricular_participation')
        input_data['extracurricular_participation_No'] = no
        input_data['extracurricular_participation_Yes'] = yes

    # Handle part_time_job
    if 'part_time_job' in input_data:
        no, yes = encode_part_time_job(input_data['part_time_job'])
        input_data.pop('part_time_job')
        input_data['part_time_job_No'] = no
        input_data['part_time_job_Yes'] = yes

    # Handle parental_education_level
    if 'parental_education_level' in input_data:
        bachelor, high_school, master, unknown = encode_parental_education(input_data['parental_education_level'])
        input_data.pop('parental_education_level')
        input_data['parental_education_level_Bachelor'] = bachelor
        input_data['parental_education_level_High School'] = high_school
        input_data['parental_education_level_Master'] = master
        input_data['parental_education_level_Unknown'] = unknown

    # Handle diet_quality
    if 'diet_quality' in input_data:
        fair, good, poor = encode_diet_quality(input_data['diet_quality'])
        input_data.pop('diet_quality')
        input_data['diet_quality_Fair'] = fair
        input_data['diet_quality_Good'] = good
        input_data['diet_quality_Poor'] = poor

    # Create DataFrame
    input_df = pd.DataFrame([input_data])

    # Columns your model expects
    expected_cols = [
        'age', 'study_hours_per_day', 'social_media_hours', 'attendance_percentage',
        'sleep_hours', 'exercise_frequency', 'mental_health_rating',
        'gender_Female', 'gender_Male', 'gender_Other',
        'part_time_job_No', 'part_time_job_Yes',
        'diet_quality_Fair', 'diet_quality_Good', 'diet_quality_Poor',
        'parental_education_level_Bachelor', 'parental_education_level_High School',
        'parental_education_level_Master', 'parental_education_level_Unknown',
        'extracurricular_participation_No', 'extracurricular_participation_Yes'
    ]

    # Add missing columns with 0
    for col in expected_cols:
        if col not in input_df.columns:
            input_df[col] = 0

    # Reorder columns to match model input
    input_df = input_df[expected_cols]

    # Predict
    score = model.predict(input_df)[0]
    return round(score, 2)

student_input = {
    'age': 22,
    'study_hours_per_day': 4,
    'social_media_hours': 2,
    'attendance_percentage': 95,
    'sleep_hours': 7,
    'exercise_frequency': 4,
    'mental_health_rating': 8,
    'gender': 'Male',
    'extracurricular_participation': 'Yes',
    'part_time_job': 'No',
    'parental_education_level': 'Bachelor',
    'diet_quality': 'Good'
}

predicted_score = predict_exam_score_flexible(model, student_input)
print("Predicted Exam Score:", predicted_score)